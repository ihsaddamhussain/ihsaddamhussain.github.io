<!DOCTYPE html>
<html lang="en">
  <head>
  <title>Overhead of Returning Optional Values in Java and Rust | Piotr Kołaczkowski</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Some programming languages like Java or Scala offer more than one way to express a concept of “lack of value”. Traditionally, a special null value is used to...">
  <meta name="author" content="Piotr Kołaczkowski">
  <meta name="generator" content="Jekyll v4.1.1">
  <!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-PBJQD2M');</script>
<!-- End Google Tag Manager -->

  <link rel="canonical" href="/overhead-of-optional/">
  
  <link rel="stylesheet" href="/assets/css/index.css">
  
  <link rel="stylesheet" href="/assets/css/classes.css">
  <link rel="stylesheet" href="/assets/css/sidebar.css" media="screen and (min-width: 70em)">
  <link rel="alternate" href="/feed.xml" type="application/atom+xml" title="Piotr Kołaczkowski">
  
  
  <script defer src="/assets/node_modules/chart.js/dist/Chart.min.js"></script>
</head>
<body>
  <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBJQD2M"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
  <header class="icons">
    
      <a href="/" class="title">Piotr Kołaczkowski</a>
    
    
      
  <nav>
  <a aria-label="Home" href="/" ><svg aria-hidden="true" class="hidden"><use xlink:href="/assets/fontawesome/icons.svg#home"></use></svg><span aria-hidden="true" >Home</span></a>
  <a aria-label="About" href="/about/" ><svg aria-hidden="true" class="hidden"><use xlink:href="/assets/fontawesome/icons.svg#address-card"></use></svg><span aria-hidden="true" >About</span></a>
  
  </nav>


      
  <nav>
  <a aria-label="Mail" href="mailto:pkolaczk@gmail.com" ><svg aria-hidden="true" ><use xlink:href="/assets/fontawesome/icons.svg#envelope"></use></svg><span aria-hidden="true" class="hidden">Mail</span></a>
  <a aria-label="Github" href="https://github.com/pkolaczk" ><svg aria-hidden="true" ><use xlink:href="/assets/fontawesome/icons.svg#github"></use></svg><span aria-hidden="true" class="hidden">Github</span></a>
  <a aria-label="LinkedIn" href="https://www.linkedin.com/in/pkolaczk" ><svg aria-hidden="true" ><use xlink:href="/assets/fontawesome/icons.svg#linkedin"></use></svg><span aria-hidden="true" class="hidden">LinkedIn</span></a>
  <a aria-label="RSS" href="/feed.xml" ><svg aria-hidden="true" ><use xlink:href="/assets/fontawesome/icons.svg#rss"></use></svg><span aria-hidden="true" class="hidden">RSS</span></a>
  
  </nav>


    
    
      <div class="hidden description">Blog on programming, optimization and performance analysis</div>
    

  </header>

  <article>
  <header>
  
  <h1><a href="/overhead-of-optional/">Overhead of Returning Optional Values in Java and Rust</a></h1><time datetime="2021-10-16T00:00:00+02:00">October 16, 2021</time>
</header>

  <p>Some programming languages like Java or Scala offer more than one way to express
a concept of “lack of value”. Traditionally, a special <code class="language-plaintext highlighter-rouge">null</code> value is used to denote
references that don’t reference any value at all. However, over time we 
have learned that using <code class="language-plaintext highlighter-rouge">null</code>s can be very error-prone and can cause many troubles like 
<code class="language-plaintext highlighter-rouge">NullPointerException</code> errors crashing a program in the most unexpected moment. 
Therefore, modern programming style recommends avoiding <code class="language-plaintext highlighter-rouge">nulls</code> wherever possible 
in favor of a much better <code class="language-plaintext highlighter-rouge">Option</code>, <code class="language-plaintext highlighter-rouge">Optional</code> or <code class="language-plaintext highlighter-rouge">Maybe</code> data type 
(called differently in many languages, but the concept is the same).
Unfortunately, it is believed that optional values in Java may come with a 
performance penalty. In this blog post, I’ll try to answer whether 
it is true, and if the performance penalty really exists, how serious it is.</p>

<!--more-->

<p>Before we start, let me point out that if you don’t care much about extreme runtime performance, 
you should never use <code class="language-plaintext highlighter-rouge">null</code> in Java nor Scala, except for in rare cases of working with legacy APIs. 
Just forget <code class="language-plaintext highlighter-rouge">null</code> ever existed in the language. And if you receive an occasional <code class="language-plaintext highlighter-rouge">null</code> from an API 
you can’t control, just wrap it immediately in <code class="language-plaintext highlighter-rouge">Optional&lt;T&gt;</code> / <code class="language-plaintext highlighter-rouge">Option[T]</code>. Don’t let <code class="language-plaintext highlighter-rouge">nulls</code> bite you. 
You won’t regret it. To learn the reasons why null pointers / null references are a bad idea,
watch <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">this talk by Tony Hoare</a>.</p>

<p>Ok, but if we care about performance? How much do optionals actually cost? 
Some say optionals are expensive because they cause heap allocation and often force the underlying type to be boxed.
Not only heap allocation is costly, but it also forces the garbage collector to run more frequently.
Others say that it doesn’t really matter, because the JVM compiler will eliminate the overhead thanks to inlining and escape analysis,
and in most cases it should transform the code to an equivalent of code using null pointers.</p>

<p>Who is right? Let’s make a quick benchmark.</p>

<h1 id="java-benchmark">Java Benchmark</h1>
<p>How to measure <code class="language-plaintext highlighter-rouge">Optional</code> overhead? The time to create an <code class="language-plaintext highlighter-rouge">Optional</code> object instance, even assuming a pessimistic case 
of allocating it on the heap, is likely too small to measure it directly. We need to create many <code class="language-plaintext highlighter-rouge">Optional</code> objects 
in a tight loop and time the whole loop.</p>

<p>We also need to make sure the compiler doesn’t notice the code does nothing or does
something trivial. We don’t want the loop to be eliminated. 
A proper way of dealing with this problem is using all of the <code class="language-plaintext highlighter-rouge">Optional</code> objects we create so that
their values affect the final result computed in the benchmark. Then the final result must be consumed by a black hole. 
Fortunately a benchmarking tool like <a href="https://github.com/openjdk/jmh">JMH</a> makes it all easy.</p>

<p>I created three variants of code solving the same task. The task was to compute a sum of all the numbers, skipping the number 
whenever it is equal to a magic constant. The variants differ by the way how skipping is realized:</p>

<ol>
  <li>We return primitive <code class="language-plaintext highlighter-rouge">long</code>s and check if we need to skip by performing a comparison with the magic value directly in the summing loop.</li>
  <li>We return boxed <code class="language-plaintext highlighter-rouge">Long</code>s and we return <code class="language-plaintext highlighter-rouge">null</code> whenever we need to skip a number.</li>
  <li>We return boxed <code class="language-plaintext highlighter-rouge">Long</code>s wrapped in <code class="language-plaintext highlighter-rouge">Optional</code> and we return <code class="language-plaintext highlighter-rouge">Optional.empty()</code> whenever we need to skip a number.</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@State</span><span class="o">(</span><span class="nc">Scope</span><span class="o">.</span><span class="na">Benchmark</span><span class="o">)</span>
<span class="nd">@Fork</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="nd">@Warmup</span><span class="o">(</span><span class="n">iterations</span> <span class="o">=</span> <span class="mi">2</span><span class="o">)</span>
<span class="nd">@Measurement</span><span class="o">(</span><span class="n">iterations</span> <span class="o">=</span> <span class="mi">5</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OptionBenchmark</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">MAGIC_NUMBER</span> <span class="o">=</span> <span class="mi">7</span><span class="o">;</span>

    <span class="c1">// Variant 1.</span>
    <span class="c1">// Probably the simplest way to sum numbers.</span>
    <span class="c1">// No boxing, no objects involved, just primitive long values everywhere.</span>
    <span class="c1">// This is probably what a C-programmer converted to Java would write ;)</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="nf">getNumber</span><span class="o">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Benchmark</span>
    <span class="nd">@BenchmarkMode</span><span class="o">(</span><span class="nc">Mode</span><span class="o">.</span><span class="na">AverageTime</span><span class="o">)</span>
    <span class="nd">@OutputTimeUnit</span><span class="o">(</span><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MICROSECONDS</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">sumSimple</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1_000_000</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="n">getNumber</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="no">MAGIC_NUMBER</span><span class="o">)</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Variant 2.</span>
    <span class="c1">// Replace MAGIC_NUMBER with a null.</span>
    <span class="c1">// To be able to return null, we need to box long into a Long object.</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="nf">getNumberOrNull</span><span class="o">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">==</span> <span class="no">MAGIC_NUMBER</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Benchmark</span>
    <span class="nd">@BenchmarkMode</span><span class="o">(</span><span class="nc">Mode</span><span class="o">.</span><span class="na">AverageTime</span><span class="o">)</span>
    <span class="nd">@OutputTimeUnit</span><span class="o">(</span><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MICROSECONDS</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">sumNulls</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1_000_000</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Long</span> <span class="n">n</span> <span class="o">=</span> <span class="n">getNumberOrNull</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="c1">// Variant 3.</span>
    <span class="c1">// Replace MAGIC_NUMBER with Optional.empty().</span>
    <span class="c1">// Now we not only need to box the value into a Long, but also create the Optionsl wrapper.</span>
    <span class="kd">private</span> <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="nf">getOptionalNumber</span><span class="o">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">==</span> <span class="no">MAGIC_NUMBER</span> <span class="o">?</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">()</span> <span class="o">:</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Benchmark</span>
    <span class="nd">@BenchmarkMode</span><span class="o">(</span><span class="nc">Mode</span><span class="o">.</span><span class="na">AverageTime</span><span class="o">)</span>
    <span class="nd">@OutputTimeUnit</span><span class="o">(</span><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MICROSECONDS</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">sumOptional</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1_000_000</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">getOptionalNumber</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">n</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h1 id="results">Results</h1>

<p>Obviously all variants compute the same sum, so a <em>sufficiently smart compiler</em> should be able to generate exactly the same machine 
code for all of them. The method returning the number is very short and trivial, so I was expecting the compiler to inline it,
remove all of object overhead through escape analysis, unroll and maybe even vectorize the loop.
The number of invocations is constant and known at compile time, and the computations are trivial.
Real code in real projects is usually not as simple as this microbenchmark, so we’re essentially testing the best-case scenario here.</p>

<p>OpenJDK 8 (JDK 1.8.0_292, OpenJDK 64-Bit Server VM, 25.292-b10):</p>
<pre>
Benchmark                    Mode  Cnt     Score     Error  Units
OptionBenchmark.sumSimple    avgt    5  1141,557 ± 366,538  us/op
OptionBenchmark.sumNulls     avgt    5  2324,597 ±  79,033  us/op
OptionBenchmark.sumOptional  avgt    5  4576,383 ± 288,571  us/op
</pre>

<p>OpenJDK 11 (Java HotSpot(TM) 64-Bit Server VM, 11+28):</p>
<pre>
Benchmark                    Mode  Cnt     Score     Error  Units
OptionBenchmark.sumSimple    avgt    5   603,683 ±  13,246  us/op
OptionBenchmark.sumNulls     avgt    5  2444,626 ±  35,236  us/op
OptionBenchmark.sumOptional  avgt    5  4303,527 ± 109,900  us/op
</pre>

<p>Graal Community 21.2 (JDK 16.0.2, OpenJDK 64-Bit Server VM, 16.0.2+7-jvmci-21.2-b08):</p>
<pre>
OptionBenchmark.sumSimple    avgt    5   868,155 ±  42,103  us/op
OptionBenchmark.sumNulls     avgt    5  1937,866 ±  29,938  us/op
OptionBenchmark.sumOptional  avgt    5  4201,451 ± 613,179  us/op
</pre>

<p>OpenJDK 17 (JDK 17-ea, OpenJDK 64-Bit Server VM, 17-ea+19-Ubuntu-1ubuntu1):</p>
<pre>
Benchmark                    Mode  Cnt     Score     Error  Units
OptionBenchmark.sumSimple    avgt    5   449,811 ±  60,889  us/op
OptionBenchmark.sumNulls     avgt    5   952,622 ±  84,138  us/op
OptionBenchmark.sumOptional  avgt    5  4002,787 ± 264,937  us/op
</pre>

<p>Seriously, these outcomes are totally not what I expected. In all cases
JVM did a poor job of eliminating both the boxing and the optionals. 
This led to about 8x worse timings for looping over optionals than looping 
over primitive longs on JDK 17. I even reran the benchmarks 
with explicit <code class="language-plaintext highlighter-rouge">-XX:+DoEscapeAnalysis -XX:+Inline</code> to make sure these are turned on, 
but that hasn’t changed anything (they should be enabled by default anyway).</p>

<p>At least, there is a steady progress in performance between different JDK versions.</p>

<h2 id="disabling-inlining">Disabling Inlining</h2>
<p>In real production code it can also happen that a method that returns an <code class="language-plaintext highlighter-rouge">Optional</code> doesn’t get inlined.
How does it affect the overhead? I reran the benchmarks with <code class="language-plaintext highlighter-rouge">-XX:-Inline</code> option:</p>

<p>JDK 1.8.0_292, OpenJDK 64-Bit Server VM, 25.292-b10:</p>
<pre>
Benchmark                    Mode  Cnt      Score      Error  Units
OptionBenchmark.sumSimple    avgt    5   2244,281 ± 1271,115  us/op
OptionBenchmark.sumNulls     avgt    5   9024,197 ±  391,510  us/op
OptionBenchmark.sumOptional  avgt    5  20045,933 ±  777,194  us/op

</pre>

<p>JDK 11, Java HotSpot(TM) 64-Bit Server VM, 11+28</p>
<pre>
Benchmark                    Mode  Cnt      Score      Error  Units
OptionBenchmark.sumSimple    avgt    5   2385,597 ±  323,662  us/op
OptionBenchmark.sumNulls     avgt    5   7900,140 ± 2841,416  us/op
OptionBenchmark.sumOptional  avgt    5  20507,346 ± 5236,451  us/op
</pre>

<p>JDK 17-ea, OpenJDK 64-Bit Server VM, 17-ea+19-Ubuntu-1ubuntu1:</p>
<pre>
Benchmark                    Mode  Cnt      Score      Error  Units
OptionBenchmark.sumSimple    avgt    5   2382,109 ± 1346,017  us/op
OptionBenchmark.sumNulls     avgt    5   7664,463 ± 2040,463  us/op
OptionBenchmark.sumOptional  avgt    5  17961,942 ±  773,224  us/op
</pre>

<p>Everything got much slower, but optionals and boxing overhead are still clearly visible and the ratio
is still more than 7x. Rhe difference between JDKs is much smaller this time.</p>

<h1 id="rust-benchmark">Rust Benchmark</h1>

<p>I’ve rewritten everything to Rust because Rust also has optional values, and I was curious if a similar 
difference would be present. The code was trivial to port, except the variant that was using nulls, because Rust has no nulls 
(which is IMHO a good thing). Instead, I added two more variants:</p>
<ul>
  <li>A variant with <code class="language-plaintext highlighter-rouge">NonZeroU64</code> (non zero integer) which should allow the compiler to get rid of the option overhead, 
and just use value <code class="language-plaintext highlighter-rouge">0</code> for representing <code class="language-plaintext highlighter-rouge">None</code>.</li>
  <li>A special “I would never write Rust like that” variant that returns the value in a <code class="language-plaintext highlighter-rouge">Box</code> on the heap. This is because a friend
of mine, after seeing my results, told me I was cheating, because all Rust versions so far used registers/stack to return the value, 
and Java was at a disadvantage due to returning on the heap (by default). So here you are.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">num</span><span class="p">::</span><span class="n">NonZeroU64</span><span class="p">;</span>

<span class="k">const</span> <span class="n">MAGIC</span><span class="p">:</span> <span class="nb">u64</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">get_int</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
    <span class="n">n</span> <span class="o">&amp;</span> <span class="mi">0xFF</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sum_simple</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1_000_000</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">get_int</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">MAGIC</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">sum</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">get_optional_int</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="mi">0xFF</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">MAGIC</span> <span class="p">{</span> <span class="nb">None</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nf">Some</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>


<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sum_optional</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1_000_000</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="nf">get_optional_int</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">value</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">k</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">sum</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">get_optional_non_zero</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonZeroU64</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="mi">0xFF</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">MAGIC</span> <span class="p">{</span> <span class="nb">None</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nn">NonZeroU64</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sum_optional_non_zero</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1_000_000</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">value</span> <span class="o">=</span> <span class="nf">get_optional_non_zero</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">value</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">k</span><span class="nf">.get</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">sum</span>
<span class="p">}</span>


<span class="k">fn</span> <span class="nf">get_int_boxed</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">0xFF</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sum_boxed</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1_000_000</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">get_int_boxed</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="o">*</span><span class="n">n</span> <span class="o">!=</span> <span class="n">MAGIC</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">sum</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="results-1">Results</h2>
<p>Let the numbers speak for themselves.</p>

<p>With inlining, compiled specifically for my CPU with <code class="language-plaintext highlighter-rouge">RUSTFLAGS="-C target-cpu=native"</code>:</p>
<pre>
sum_simple              time:   [121.33 us 121.60 us 121.89 us]                        
sum_optional            time:   [121.65 us 121.97 us 122.29 us]                         
sum_optional_non_zero   time:   [123.22 us 123.71 us 124.26 us]                                  
sum_boxed               time:   [122.36 us 123.19 us 124.21 us]    
</pre>

<p>With default release options:</p>
<pre>
sum_simple              time:   [375.58 us 377.02 us 378.73 us]                        
sum_optional            time:   [373.19 us 374.20 us 375.31 us]                         
sum_optional_non_zero   time:   [373.09 us 374.24 us 375.60 us]                                  
sum_boxed               time:   [374.15 us 376.07 us 378.38 us]                      
</pre>

<p>With default release options, but with inlining of the inner functions 
returning the number blocked by <code class="language-plaintext highlighter-rouge">#[inline(never)]</code>:</p>
<pre>
sum_simple              time:   [1.3899 ms 1.3940 ms 1.3987 ms]                         
sum_optional            time:   [1.4066 ms 1.4117 ms 1.4177 ms]                          
sum_optional_non_zero   time:   [1.1041 ms 1.1089 ms 1.1145 ms]                                   
sum_boxed               time:   [14.572 ms 14.629 ms 14.692 ms]     
</pre>

<h1 id="analysis">Analysis</h1>

<p>Why has Java scored so bad compared to Rust?</p>

<p>I added the <code class="language-plaintext highlighter-rouge">-perfasm</code> option to the JMH options of the <code class="language-plaintext highlighter-rouge">sumOptional</code> Java benchmark 
and it resulted in the following disassembly output (I’m actually showing only a relevant fragment of it):</p>

<pre>
  0,01%   ╭ │     0x00007fcc78d3a3eb:   jmp    0x00007fcc78d3a495           ;*goto {reexecute=0 rethrow=0 return_oop=0}
          │ │                                                               ; - pk.OptionBenchmark::sumOptional@45 (line 73)
  0,31%   │ │  ↗  0x00007fcc78d3a3f0:   mov    QWORD PTR [r15+0x108],rsi
  3,08%   │ │  │  0x00007fcc78d3a3f7:   prefetchw BYTE PTR [rsi+0xc0]
  3,34%   │ │  │  0x00007fcc78d3a3fe:   mov    QWORD PTR [r10],0x1
  0,24%   │ │  │  0x00007fcc78d3a405:   mov    DWORD PTR [r10+0x8],0x49770  ;   {metadata(&apos;java/lang/Long&apos;)}
  0,54%   │ │  │  0x00007fcc78d3a40d:   mov    DWORD PTR [r10+0xc],r12d     ;*new {reexecute=0 rethrow=0 return_oop=0}
          │ │  │                                                            ; - java.lang.Long::valueOf@31 (line 1211)
          │ │  │                                                            ; - pk.OptionBenchmark::getOptionalNumber@21 (line 65)
          │ │  │                                                            ; - pk.OptionBenchmark::sumOptional@14 (line 74)
  2,55%   │ │  │  0x00007fcc78d3a411:   mov    QWORD PTR [r10+0x10],r11
  1,58%   │ │ ↗│  0x00007fcc78d3a415:   mov    rax,QWORD PTR [r15+0x108]
  2,71%   │ │ ││  0x00007fcc78d3a41c:   mov    r11,rax
  0,72%   │ │ ││  0x00007fcc78d3a41f:   add    r11,0x10
  3,48%   │ │ ││  0x00007fcc78d3a423:   cmp    r11,QWORD PTR [r15+0x118]
          │ │ ││  0x00007fcc78d3a42a:   jae    0x00007fcc78d3a574           ;*goto {reexecute=0 rethrow=0 return_oop=0}
          │ │ ││                                                            ; - pk.OptionBenchmark::sumOptional@45 (line 73)
  1,90%   │ │ ││  0x00007fcc78d3a430:   mov    QWORD PTR [r15+0x108],r11
  1,80%   │ │ ││  0x00007fcc78d3a437:   prefetchw BYTE PTR [r11+0xc0]
  5,22%   │ │ ││  0x00007fcc78d3a43f:   mov    QWORD PTR [rax],0x1
  3,78%   │ │ ││  0x00007fcc78d3a446:   mov    DWORD PTR [rax+0x8],0x11af00 ;*new {reexecute=0 rethrow=0 return_oop=0}
          │ │ ││                                                            ; - java.util.Optional::of@0 (line 113)
          │ │ ││                                                            ; - pk.OptionBenchmark::getOptionalNumber@24 (line 65)
          │ │ ││                                                            ; - pk.OptionBenchmark::sumOptional@14 (line 74)
          │ │ ││                                                            ;   {metadata(&apos;java/util/Optional&apos;)}
  2,20%   │ │ ││  0x00007fcc78d3a44d:   mov    r11,r10
  1,54%   │ │ ││  0x00007fcc78d3a450:   shr    r11,0x3
  0,87%   │ │ ││  0x00007fcc78d3a454:   mov    DWORD PTR [rax+0xc],r11d     ;*synchronization entry
          │ │ ││                                                            ; - pk.OptionBenchmark::getOptionalNumber@-1 (line 64)
          │ │ ││                                                            ; - pk.OptionBenchmark::sumOptional@14 (line 74)
  3,23%   │ │ ││  0x00007fcc78d3a458:   mov    r11d,DWORD PTR [rax+0xc]     ;*getfield value {reexecute=0 rethrow=0 return_oop=0}
          │ │ ││                                                            ; - java.util.Optional::isPresent@1 (line 154)
          │ │ ││                                                            ; - pk.OptionBenchmark::sumOptional@21 (line 75)
  2,24%   │ │ ││  0x00007fcc78d3a45c:   nop    DWORD PTR [rax+0x0]
  1,47%   │ │ ││  0x00007fcc78d3a460:   test   r11d,r11d
          │╭│ ││  0x00007fcc78d3a463:   je     0x00007fcc78d3a47f
  2,72%   │││ ││  0x00007fcc78d3a465:   mov    r10d,DWORD PTR [r12+r11*8+0x8]
 11,00%   │││ ││  0x00007fcc78d3a46a:   shl    r11,0x3
  0,92%   │││ ││  0x00007fcc78d3a46e:   cmp    r10d,0x49770                 ;*synchronization entry
          │││ ││                                                            ; - pk.OptionBenchmark::getOptionalNumber@-1 (line 64)
          │││ ││                                                            ; - pk.OptionBenchmark::sumOptional@14 (line 74)
          │││ ││                                                            ;   {metadata(&apos;java/lang/Long&apos;)}
          │││ ││  0x00007fcc78d3a475:   jne    0x00007fcc78d3a687           ;*checkcast {reexecute=0 rethrow=0 return_oop=0}
          │││ ││                                                            ; - pk.OptionBenchmark::sumOptional@33 (line 76)
  4,53%   │││ ││  0x00007fcc78d3a47b:   add    rcx,QWORD PTR [r11+0x10]     ;*lload_3 {reexecute=0 rethrow=0 return_oop=0}
          │││ ││                                                            ; - pk.OptionBenchmark::sumOptional@41 (line 73)
  5,89%   │↘│ ││  0x00007fcc78d3a47f:   add    r8,0x1
  0,92%   │ │ ││  0x00007fcc78d3a483:   mov    r11,r8                       ;*synchronization entry
          │ │ ││                                                            ; - pk.OptionBenchmark::getOptionalNumber@-1 (line 64)
          │ │ ││                                                            ; - pk.OptionBenchmark::sumOptional@14 (line 74)
  0,62%   │ │ ││  0x00007fcc78d3a486:   movzx  r11,r11b                     ;*land {reexecute=0 rethrow=0 return_oop=0}
          │ │ ││                                                            ; - pk.OptionBenchmark::getOptionalNumber@4 (line 64)
          │ │ ││                                                            ; - pk.OptionBenchmark::sumOptional@14 (line 74)
  1,14%   │ │ ││  0x00007fcc78d3a48a:   inc    edi
  4,42%   │ │ ││  0x00007fcc78d3a48c:   cmp    edi,r9d
          │ ╰ ││  0x00007fcc78d3a48f:   jge    0x00007fcc78d3a3b3
</pre>

<p>My knowledge of Intel assembly is quite limited, but I can clearly see a few things:</p>
<ul>
  <li>The call to <code class="language-plaintext highlighter-rouge">getOptionalNumber</code> got inlined. There are no calls anywhere in the body of the loop. This is good.</li>
  <li>There is a lot of code caused by allocating and initializing the <code class="language-plaintext highlighter-rouge">Long</code> instance. 
We can see <code class="language-plaintext highlighter-rouge">java.lang.Long::valueOf@31 (line 1211)</code> got inlined, but the allocation hasn’t been eliminated. This is very bad.</li>
  <li>There is a similar problem with the <code class="language-plaintext highlighter-rouge">Option</code> object - it got inlined, but it is still allocated on the heap and 
its internal structure remained intact. I was hoping for a scalar-replacement here, but weirdly it hasn’t happened.</li>
  <li>The number to be summed is being copied out from the <code class="language-plaintext highlighter-rouge">Option</code> object. There are many needless data transfers between memory and registers.</li>
  <li>Skipping the magic number is performed by a conditional jump. In this case it is probably not a problem, 
because we’re skipping just one number per 256, but this could potentially cause branch misprediction if the ratio was different and not so regular.</li>
  <li>No SSE/AVX used anywhere. It treated my CPU as if it was some ancient Pentium :(</li>
</ul>

<p>To confirm my interpretation of the disassembly, I also ran all the benchmarks with <code class="language-plaintext highlighter-rouge">-perf gc</code>:</p>
<pre>
Benchmark                                                     Mode  Cnt         Score        Error   Units
OptionBenchmark.sumSimple:·gc.alloc.rate                      avgt    5        ≈ 10⁻⁴               MB/sec
OptionBenchmark.sumSimple:·gc.count                           avgt    5           ≈ 0               counts

OptionBenchmark.sumNulls:·gc.alloc.rate                       avgt    5        ≈ 10⁻⁴               MB/sec
OptionBenchmark.sumNulls:·gc.count                            avgt    5           ≈ 0               counts

OptionBenchmark.sumOptional:·gc.alloc.rate                    avgt    5      6193,432 ±    424,465  MB/sec
OptionBenchmark.sumOptional:·gc.count                         avgt    5       546,000               counts
</pre>

<p>As you can see, the <code class="language-plaintext highlighter-rouge">sumOptional</code> benchmark was allocating at rate over 6 GB/s!</p>

<h2 id="rust-output-code">Rust output code</h2>
<p>The code generated by Rust using default options looks much simpler:</p>

<pre>
            Disassembly of section .text:
               
            0000000000050f40 &lt;benchmark::sum_optional&gt;:
            benchmark::sum_optional:
              mov    $0x4,%ecx
              xor    %edx,%edx
              xor    %eax,%eax
              nop           
  2,67  10:   lea    -0x4(%rcx),%esi
  5,65        lea    -0x3(%rcx),%edi
  2,61        movzbl %sil,%esi
  4,29        cmp    $0x7,%rsi
  2,76        cmove  %rdx,%rsi
  5,71        add    %rax,%rsi
  2,47        lea    -0x2(%rcx),%eax
  4,41        movzbl %dil,%edi
  2,69        cmp    $0x7,%rdi
  6,05        cmove  %rdx,%rdi
  3,29        add    %rsi,%rdi
  3,98        lea    -0x1(%rcx),%esi
  2,53        movzbl %al,%eax
  5,09        cmp    $0x7,%rax
  3,37        cmove  %rdx,%rax
  4,76        add    %rdi,%rax
  2,75        movzbl %sil,%esi
  4,80        cmp    $0x7,%rsi
  3,15        cmove  %rdx,%rsi
  5,64        add    %rax,%rsi
  2,23        movzbl %cl,%eax
  4,18        cmp    $0x7,%rax
  2,78        cmove  %rdx,%rax
  5,31        add    %rsi,%rax
  2,44        add    $0x5,%rcx
              cmp    $0xf4244,%rcx
  4,40      ↑ jne    10     
  0,01      ← ret           
</pre>

<p>The code is much shorter, even despite the fact the loop has been unrolled. It is also way simpler and easier to understand.
In the body of the loop there are no moves between memory and registers, and there are no branches.
Skipping the number is performed with a conditional move instruction which looks like a very natural choice to me.</p>

<p>It is worth noting the code for all of four variants is identical and the compiler even merged copies into one.
The compiler managed to get rid of all the overhead of <code class="language-plaintext highlighter-rouge">Option</code> and <code class="language-plaintext highlighter-rouge">Box</code>.
These abstrations turned out to be truly zero-cost!</p>

<p>As a final check I compiled the benchmark with <code class="language-plaintext highlighter-rouge">RUSTFLAGS="-C target-cpu=native"</code>:</p>

<pre>
             Disassembly of section .text:
               
             0000000000057d50 &lt;benchmark::sum_classic&gt;:
             btree_benchmark::sum_optional:
               sub          $0x38,%rsp
  0,00         vmovdqa      anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x4d0,%ymm0
               vpxor        %xmm11,%xmm11,%xmm11
               mov          $0xf4240,%eax
               vpbroadcastq 0x1d5b31(%rip),%ymm1        # 22d8a0 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x4f0&gt;
               vmovdqu      %ymm1,(%rsp)
               vpbroadcastq 0x1d5b2b(%rip),%ymm2        # 22d8a8 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x4f8&gt;
               vpbroadcastq 0x1d5b2a(%rip),%ymm3        # 22d8b0 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x500&gt;
               vpbroadcastq 0x1d5b29(%rip),%ymm4        # 22d8b8 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x508&gt;
               vpbroadcastq 0x1d5b28(%rip),%ymm5        # 22d8c0 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x510&gt;
               vpbroadcastq 0x1d5b27(%rip),%ymm6        # 22d8c8 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x518&gt;
               vpbroadcastq 0x1d5b26(%rip),%ymm7        # 22d8d0 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x520&gt;
               vpbroadcastq 0x1d5b25(%rip),%ymm8        # 22d8d8 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x528&gt;
               vpbroadcastq 0x1d5b24(%rip),%ymm9        # 22d8e0 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x530&gt;
               vpbroadcastq 0x1d5b23(%rip),%ymm10        # 22d8e8 &lt;anon.b26f45dd7d0ea1d60480ae6c3c88753d.34.llvm.65588711349491208+0x538&gt;
               vpxor        %xmm12,%xmm12,%xmm12
               vpxor        %xmm13,%xmm13,%xmm13
               vpxor        %xmm14,%xmm14,%xmm14
               data16       data16 cs nopw 0x0(%rax,%rax,1)
  1,34   90:   vpand        %ymm4,%ymm0,%ymm15
  3,66         vpcmpeqq     %ymm5,%ymm15,%ymm1
  3,04         vpandn       %ymm15,%ymm1,%ymm1
  0,96         vpaddq       (%rsp),%ymm0,%ymm15
  1,25         vpand        %ymm4,%ymm15,%ymm15
  3,51         vpaddq       %ymm1,%ymm11,%ymm1
  2,94         vpcmpeqq     %ymm5,%ymm15,%ymm11
  2,25         vpandn       %ymm15,%ymm11,%ymm11
  0,80         vpaddq       %ymm2,%ymm0,%ymm15
  3,11         vpand        %ymm4,%ymm15,%ymm15
  3,38         vpaddq       %ymm12,%ymm11,%ymm12
  2,45         vpcmpeqq     %ymm5,%ymm15,%ymm11
  1,73         vpandn       %ymm15,%ymm11,%ymm11
  1,92         vpaddq       %ymm3,%ymm0,%ymm15
  2,93         vpand        %ymm4,%ymm15,%ymm15
  4,20         vpaddq       %ymm13,%ymm11,%ymm13
  1,64         vpcmpeqq     %ymm5,%ymm15,%ymm11
  2,02         vpandn       %ymm15,%ymm11,%ymm11
  4,99         vpaddq       %ymm14,%ymm11,%ymm14
  2,13         vpaddq       %ymm6,%ymm0,%ymm11
  0,66         vpand        %ymm4,%ymm11,%ymm11
  1,97         vpcmpeqq     %ymm5,%ymm11,%ymm15
  4,79         vpandn       %ymm11,%ymm15,%ymm11
  1,72         vpaddq       %ymm7,%ymm0,%ymm15
  0,67         vpand        %ymm4,%ymm15,%ymm15
  2,54         vpaddq       %ymm1,%ymm11,%ymm11
  3,66         vpcmpeqq     %ymm5,%ymm15,%ymm1
  2,39         vpandn       %ymm15,%ymm1,%ymm1
  0,42         vpaddq       %ymm0,%ymm8,%ymm15
  2,02         vpand        %ymm4,%ymm15,%ymm15
  4,75         vpaddq       %ymm1,%ymm12,%ymm12
  2,23         vpcmpeqq     %ymm5,%ymm15,%ymm1
  1,99         vpandn       %ymm15,%ymm1,%ymm1
  1,44         vpaddq       %ymm0,%ymm9,%ymm15
  3,94         vpand        %ymm4,%ymm15,%ymm15
  4,01         vpaddq       %ymm1,%ymm13,%ymm13
  1,84         vpcmpeqq     %ymm5,%ymm15,%ymm1
  1,90         vpandn       %ymm15,%ymm1,%ymm1
  3,97         vpaddq       %ymm1,%ymm14,%ymm14
  1,96         vpaddq       %ymm0,%ymm10,%ymm0
  0,00         add          $0xffffffffffffffe0,%rax
  0,84       ↑ jne          90
  0,00         vpaddq       %ymm11,%ymm12,%ymm0
  0,00         vpaddq       %ymm0,%ymm13,%ymm0
               vpaddq       %ymm0,%ymm14,%ymm0
               vextracti128 $0x1,%ymm0,%xmm1
               vpaddq       %xmm1,%xmm0,%xmm0
               vpshufd      $0xee,%xmm0,%xmm1
  0,00         vpaddq       %xmm1,%xmm0,%xmm0
               vmovq        %xmm0,%rax
               add          $0x38,%rsp
               vzeroupper     
  0,00       ← ret            

</pre>

<p>The loop got nicely vectorised and there are no branches inside the body of the loop either.
It is a bit longer, but it does more per each cycle of the loop and needs fewer cycles.</p>

<h1 id="conclusions">Conclusions</h1>
<ul>
  <li>Using <code class="language-plaintext highlighter-rouge">Optional</code> values in an extremely performance sensitive Java code is likely a bad idea. All JVMs tested here failed to optimize them out.</li>
  <li>Wrapping primitives in <code class="language-plaintext highlighter-rouge">Optional</code> caused up to 8x speed degradation and increased allocation rate significantly. Escape analysis optimization failed.</li>
  <li>Avoid boxing numbers and nulls in Java as well. More recent JVMs seem to cope with them better, but none managed to get rid of the overhead totally.</li>
  <li>The most ugly and error-prone solution turned out to be the fastest: primitive types and magic values.</li>
  <li>Don’t count on JVM taking advantage of knowing the target CPU and utilizing modern instruction sets like AVX automatically. 
Actually even the <code class="language-plaintext highlighter-rouge">sumSimple</code> hasn’t been vectorized here, despite being a textbook case for vectorization.</li>
  <li>Knowing the actual performance profile of the program didn’t give JVM any edge here either.</li>
  <li>Fortunately, the advice above does not apply to Rust. Rust <code class="language-plaintext highlighter-rouge">Option</code> is zero-cost in most cases and, even without inlining, the added cost is tiny. 
You don’t have to trade code readability nor safety to gain speed.</li>
  <li>Rust code returning <code class="language-plaintext highlighter-rouge">Option</code> optimized for my CPU was over <strong>30x</strong> faster than Java code returning <code class="language-plaintext highlighter-rouge">Optional</code>, 
and still over <strong>10x</strong> faster if compiled in a portable way with default settings and no vectorization.</li>
  <li>Quite surprisingly, even the pessimized version of Rust code forced to allocate the <code class="language-plaintext highlighter-rouge">Option</code> on heap with no inlining was still faster than JVM doing the same. 
Is manual heap allocation not really slower than GC-based allocation? Probably a topic for another blog post.</li>
  <li>Languages and their compilers vastly differ in optimization strength. Don’t assume all languages that can compile to machine code are the same.</li>
</ul>

<p>Disclaimer: Do measure performance by yourself and don’t assume particular optimizations will / won’t take place because you saw someone mentioning them in the blog post.
YMMV.</p>

  

<style>
#share-buttons { margin-top: 2em; }
#share-buttons > a {   
    display: inline-block;
    vertical-align: baseline;
}
#share-buttons > a > svg { 
    height: 1.2em; 
    width: 1.2em; 
    margin-left: .25em; 
    margin-right: .25em; 
    fill: gray; 
    position: relative; 
    top: .17em; 
}
#share-buttons > span { 
    margin-right: .4em 
}
#share-buttons > a:hover {cursor: pointer;}
#share-buttons > a.facebook:hover > svg {fill: #3B5998;}
#share-buttons > a.twitter:hover > svg {fill: #55ACEE;}
#share-buttons > a.linkedin:hover > svg {fill: #0077b5;}
#share-buttons > a.pinterest:hover > svg {fill: #CB2027;}
#share-buttons > a.mail:hover > svg {fill: #0077b5; }
</style>

<div id="share-buttons">
    <span style="color: gray;">Share on:</span>
    <a class="facebook" title="Share this on Facebook" href="http://www.facebook.com/share.php?u=/overhead-of-optional/" target="_blank"> 
        <svg><use xlink:href="/assets/fontawesome/icons.svg#facebook"></use></svg>
    </a>
    <a class="twitter" title="Share this on Twitter" href="https://twitter.com/intent/tweet?text=/overhead-of-optional/" target="_blank">
        <svg><use xlink:href="/assets/fontawesome/icons.svg#twitter"></use></svg>
    </a>
    <a class="linkedin" title="Share this on Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=/overhead-of-optional/" target="_blank">
        <svg><use xlink:href="/assets/fontawesome/icons.svg#linkedin"></use></svg>
    </a>
    <a class="mail" title="Share this through Email" href="mailto:?&body=/overhead-of-optional/">
        <svg><use xlink:href="/assets/fontawesome/icons.svg#envelope"></use></svg>
    </a>
</div>

  
    <hr>
    
        
      <div id="disqus_thread"></div>
      <script src="/assets/disqus/disqusloader.js"></script>
      <script>        
        disqusLoader('#disqus_thread', { scriptUrl: "//pkolaczk.disqus.com/embed.js" });
      </script> 
    
    <noscript>Please enable JavaScript to view comments.</noscript>
  
</article>


  <footer class="related">
    <div class="previous"><span>Previous Post</span><a href="/disk-access-ordering/">Ordering Requests to Accelerate Disk I/O</a></div>
    <div class="next"></div>
  </footer>


</body>
</html>
