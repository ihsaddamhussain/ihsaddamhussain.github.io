<!DOCTYPE html>
<html lang="en">
  <head>
  <title>In Defense of a Switch | Piotr Kołaczkowski</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Recently I came across a blog post whose author claims, from the perspective of good coding practices, polymorphism is strictly superior to branching. In the...">
  <meta name="author" content="Piotr Kołaczkowski">
  <meta name="generator" content="Jekyll v4.1.1">
  <!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-PBJQD2M');</script>
<!-- End Google Tag Manager -->

  <link rel="canonical" href="/in-defense-of-switch/">
  
  <link rel="stylesheet" href="/assets/css/index.css">
  
  <link rel="stylesheet" href="/assets/css/classes.css">
  <link rel="stylesheet" href="/assets/css/sidebar.css" media="screen and (min-width: 70em)">
  <link rel="alternate" href="/feed.xml" type="application/atom+xml" title="Piotr Kołaczkowski">
  
  
  <script defer src="/assets/node_modules/chart.js/dist/Chart.min.js"></script>
</head>
<body>
  <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PBJQD2M"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
  <header class="icons">
    
      <a href="/" class="title">Piotr Kołaczkowski</a>
    
    
      
  <nav>
  <a aria-label="Home" href="/" ><svg aria-hidden="true" class="hidden"><use xlink:href="/assets/fontawesome/icons.svg#home"></use></svg><span aria-hidden="true" >Home</span></a>
  <a aria-label="About" href="/about/" ><svg aria-hidden="true" class="hidden"><use xlink:href="/assets/fontawesome/icons.svg#address-card"></use></svg><span aria-hidden="true" >About</span></a>
  
  </nav>


      
  <nav>
  <a aria-label="Mail" href="mailto:pkolaczk@gmail.com" ><svg aria-hidden="true" ><use xlink:href="/assets/fontawesome/icons.svg#envelope"></use></svg><span aria-hidden="true" class="hidden">Mail</span></a>
  <a aria-label="Github" href="https://github.com/pkolaczk" ><svg aria-hidden="true" ><use xlink:href="/assets/fontawesome/icons.svg#github"></use></svg><span aria-hidden="true" class="hidden">Github</span></a>
  <a aria-label="LinkedIn" href="https://www.linkedin.com/in/pkolaczk" ><svg aria-hidden="true" ><use xlink:href="/assets/fontawesome/icons.svg#linkedin"></use></svg><span aria-hidden="true" class="hidden">LinkedIn</span></a>
  <a aria-label="RSS" href="/feed.xml" ><svg aria-hidden="true" ><use xlink:href="/assets/fontawesome/icons.svg#rss"></use></svg><span aria-hidden="true" class="hidden">RSS</span></a>
  
  </nav>


    
    
      <div class="hidden description">Blog on programming, optimization and performance analysis</div>
    

  </header>

  <article>
  <header>
  
  <h1><a href="/in-defense-of-switch/">In Defense of a Switch</a></h1><time datetime="2020-09-02T00:00:00+02:00">September 02, 2020</time>
</header>

  <p>Recently I came across a <a href="https://levelup.gitconnected.com/if-else-is-a-poor-mans-polymorphism-ab0b333b7265">blog post</a>
whose author claims, from the perspective of good coding practices, polymorphism is strictly superior to branching. 
In the post they make general statements about how branching statements lead to unreadable, unmaintainable, inflexible code and
how they are a sign of immaturity. However, in my opinion, the topic is much deeper and in this post 
I try to objectively discuss the reasons for and against branching.</p>

<!--more-->

<h1 id="is-my-code-easy-to-extend">Is My Code Easy to Extend?</h1>

<p>Before I dive into polymorphism vs branching dilemma, let’s first define what we mean when we say some code is
flexible and easy to extend. In my career I reviewed thousands of lines of code, and I had thousands of lines of my code
reviewed by others, and during these reviews it often occured that the terms <em>code extensibility</em> or <em>flexibility</em> 
mean different things to different people. Familiarity with the code-base or particular programming style plays a huge role.</p>

<p>For example, someone used to writing code in a Java/C# OOP style would generally consider dynamic polymorphism through 
interfaces a standard way of providing extensibility to the code, 
while a C programmer may find a switch or if/else much more 
approachable than OOP. There are also many other factors related 
to maintainability as quality of documentation, good naming, separation of concerns, etc. These factors are orthogonal 
to the “polymorphism vs branching” dimension and also far too broad for a single blog post, so I won’t discuss them.</p>

<p>For the sake of this post, let’s define <em>extensibility</em> as the inverse of number of distinct units in the codebase
that need to be changed in order to implement a new feature. The more places you have to touch to implement the feature, 
the harder the code is to change. Obviously, it is much better when you have to touch only
one unit of code (one function, one class, one module, one package) rather than change 10 distinct unrelated units.</p>

<h1 id="example">Example</h1>
<p>Imagine you’re writing a calculator. Your program gets an expression as an input and outputs the computed value.
For example the user inputs <code class="language-plaintext highlighter-rouge">1 + 2 * 3</code> and the output is <code class="language-plaintext highlighter-rouge">7</code> 
(or <code class="language-plaintext highlighter-rouge">9</code> if you’ve messed up the operator precedence like one of my former CS students).</p>

<p>Why such a silly example? Who is writing calculators these days? Probably no-one, but this looks like a classic example given
in many programming classes. And it is easy enough to illustrate the concept.</p>

<p>How can we model a structure to represent an expression?
You’d probably use classes or structures. Here is the code in Scala:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Expression</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="k">:</span> <span class="kt">Double</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Const</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expression</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">value</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Add</span><span class="o">(</span><span class="n">left</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expression</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="nv">left</span><span class="o">.</span><span class="py">eval</span> <span class="o">+</span> <span class="nv">right</span><span class="o">.</span><span class="py">eval</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Then it is quite easy to build an expression and evaluate it:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Add</span><span class="o">(</span><span class="nc">Const</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="nc">Const</span><span class="o">(</span><span class="mi">3</span><span class="o">)).</span><span class="py">eval</span> <span class="c1">// evaluates to 5 </span>
</code></pre></div></div>

<h1 id="adding-new-classes">Adding New Classes</h1>
<p>This OOP-based solution is indeed very extensible when it comes to add a new operator.
The example above is missing subtraction operation. We can add one by defining a new class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Sub</span><span class="o">(</span><span class="n">left</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expression</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="nv">left</span><span class="o">.</span><span class="py">eval</span> <span class="o">-</span> <span class="nv">right</span><span class="o">.</span><span class="py">eval</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That’s really awesome – we didn’t have to touch any old code at all! 
OOP definitely rocks here.</p>

<h1 id="adding-new-operations">Adding New Operations</h1>
<p>Imagine you continued to extend our calculation engine with more operation classes over the next few years.
You’ve added multiplication, division, modulo, variables, logarithms, trigonometric functions, etc.</p>

<p>Then suddenly a new requirement comes – users want to not only evaluate the value of an expression,
but also do symbolic manipulation – e.g. simplify expressions. For example, given an expression
<code class="language-plaintext highlighter-rouge">a + a</code> they want to get an expression <code class="language-plaintext highlighter-rouge">2 * a</code> as a result.</p>

<p>This requirement can’t be captured by the <code class="language-plaintext highlighter-rouge">eval</code> method on the <code class="language-plaintext highlighter-rouge">Expression</code> interface. We need a new method:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Expression</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="k">:</span> <span class="kt">Double</span>
    <span class="k">def</span> <span class="nf">simplify</span><span class="k">:</span> <span class="kt">Expression</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And as the next step, they would likely want to be able to display the expression as a String:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Expression</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="k">:</span> <span class="kt">Double</span>
    <span class="k">def</span> <span class="nf">simplify</span><span class="k">:</span> <span class="kt">Expression</span>
    <span class="k">def</span> <span class="nf">toString</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span>
</code></pre></div></div>

<p>How many units of code do you have to change now to implement these features?
<strong>All the implementations of <code class="language-plaintext highlighter-rouge">Expression</code></strong>. Before touching all the classes, the code wouldn’t even compile.
It looks like in the context of this kind of feature, our polymorphic solution is terribly non-extensible.</p>

<h1 id="what-can-switch-do-about-it">What Can Switch Do About It?</h1>
<p>Let’s take a step back and let’s see how we could implement this differently.
Scala and many other modern languages have a feature called <em>pattern matching</em>
which can be considered a very flexible, powerful switch.</p>

<p>Instead of defining the operations like <code class="language-plaintext highlighter-rouge">eval</code> or <code class="language-plaintext highlighter-rouge">simplify</code> on the case classes,
let’s pull them up:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Expression</span> <span class="o">{</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Const</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expression</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Add</span><span class="o">(</span><span class="n">left</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expression</span>


<span class="k">def</span> <span class="nf">eval</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Const</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="nc">Add</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now adding a new operation like <code class="language-plaintext highlighter-rouge">Sub</code> would require two changes to the code – adding a new class
<em>and</em> adding a new case in the match (switch) statement.</p>

<p>Some may say this much worse not only because of more places to update, but because of a possibility of
forgetting to update the switches which could lead to runtime errors due to unhandled cases.
Fortunately, Scala designers thought about this by providing the <code class="language-plaintext highlighter-rouge">sealed</code> keyword, which instructs the compiler
that all case classes can be defined in the same module only. This unlocks pattern exhaustiveness analysis and the
compiler would warn about missing cases:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Expression</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Const</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expression</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Add</span><span class="o">(</span><span class="n">left</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expression</span>

<span class="k">def</span> <span class="nf">eval</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Const</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="nc">Add</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>What about adding new functions like <code class="language-plaintext highlighter-rouge">simplify</code> or <code class="language-plaintext highlighter-rouge">toString</code>? 
It requires to changle only <strong>one place</strong> – by adding the required methods. 
No changes to the existing code are needed!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">simplify</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expression</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Add</span><span class="o">(</span><span class="nc">Const</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="nc">Add</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Const</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span> <span class="n">other</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">toString</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expression</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Const</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">x</span><span class="o">.</span><span class="py">toString</span>
    <span class="k">case</span> <span class="nc">Add</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"("</span> <span class="o">+</span> <span class="nf">toString</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">+</span> <span class="s">" + "</span> <span class="o">+</span> <span class="nf">toString</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">+</span> <span class="err">"</span><span class="o">)</span> 
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h1 id="code-readability">Code Readability</h1>
<p>The blog post I mentioned in the introduction stated that using polymorphism instead of
branching leads to more readable code. I find this statement far too general and actually very debatable.</p>

<p>First, even in their own example given by the author of that blog, the solution using branching was a lot
shorter and less complex than the solution using OOP. While brief code is not always more readable than a longer version of it,
in that case, I found branching to be very explicit and easy to follow. 
It is much easier to understand the control flow
in such a program because all targets are explicitly given in a single place. In the OOP solution, 
the actual implementations are hidden behind the interface and it is much harder to find them all without additional 
help of a good IDE with a “jump to implementations” feature 
(which fortunately often works well for statically typed languages, but I’ve seen IDEs sometimes 
struggle with dynamic languages like Python).</p>

<p>Second, in general case, branching has an advantage that the function logic may depend on more than
one object type or even the actual data. For example, in the example from this post, 
the transformation <code class="language-plaintext highlighter-rouge">a * (b + c)</code> =&gt; <code class="language-plaintext highlighter-rouge">a * b + a * c</code> would depend on 
both addition and multiplication. In the classic OOP solution, would you place it in the <code class="language-plaintext highlighter-rouge">Add</code> or in the <code class="language-plaintext highlighter-rouge">Mul</code> class? 
Neither seems right. Also, putting it into one of them creates a dependency on the other one. 
An expression simplifier with code scattered accross multiple classes heavily depending on each other 
would be hard to understand.</p>

<h1 id="performance">Performance</h1>
<p>This is a blog on high performance programming, so the post would be incomplete without a 
section on performance. In theory, a sufficiently good compiler should produce the same
code regardless of the choice between branching or dynamic polymorphism, but is this the case in reality?
Compilers have limitations and often don’t generate the best result code possible.</p>

<p>Let’s consider a more realistic example this time.
Some time ago I was working on serializing/deserializing code in a database system.
I stumbled upon a set of classes that described data types. They all implemented 
a common interface defining methods for serializing and deserializing values of given data type
and also computing serialized data lenghts. The following Rust snippet is a huge simplification 
of that code, but it illustrates the concept:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="n">DataType</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">BoolType</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">IntType</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">LongType</span><span class="p">;</span>

<span class="k">impl</span> <span class="n">DataType</span> <span class="k">for</span> <span class="n">BoolType</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DataType</span> <span class="k">for</span> <span class="n">IntType</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span> <span class="mi">4</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">DataType</span> <span class="k">for</span> <span class="n">LongType</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span> <span class="mi">8</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">data_len</span><span class="p">(</span><span class="n">data_type</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">dyn</span> <span class="n">DataType</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">data_type</span><span class="nf">.len</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Given a reference to a <code class="language-plaintext highlighter-rouge">DataType</code> object, it is trivial to compute the data size associated with it, 
without knowing the exact static type:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">IntType</span><span class="p">;</span>
<span class="k">let</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">LongType</span><span class="p">;</span>
<span class="k">let</span> <span class="n">v</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="n">dyn</span> <span class="n">DataType</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="o">&amp;</span><span class="n">t1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t2</span><span class="p">];</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">data_len</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>  <span class="c">// prints 4</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">data_len</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>  <span class="c">// prints 8</span>
</code></pre></div></div>

<h2 id="performance-of-dynamic-dispatch">Performance of Dynamic Dispatch</h2>

<p>The implementation of the <code class="language-plaintext highlighter-rouge">data_len</code> function is actually very simple:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">jmpq</span> <span class="o">*</span><span class="mh">0x18</span><span class="p">(</span><span class="o">%</span><span class="nb">rsi</span><span class="p">)</span>
</code></pre></div></div>

<p>Wow! A single assembly instruction! 
It jumps to the address stored in the the vtable of the object pointed by the <code class="language-plaintext highlighter-rouge">rsi</code> register.
The target of the jump depends on the actual type of the object. Here is the code generated for <code class="language-plaintext highlighter-rouge">IntType.len</code>:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">mov</span>  <span class="kc">$</span><span class="mh">0x4</span><span class="p">,</span><span class="o">%</span><span class="nb">eax</span>
<span class="nf">retq</span>
</code></pre></div></div>

<p>The codes for the other types differ only in the constant value.</p>

<p>These are only 3 instructions to return the result. Shouldn’t it be fast? 
Let’s measure this. Let’s put more random <code class="language-plaintext highlighter-rouge">DataType</code> objects into a vector, 
iterate them and print out the sum of the values returned by <code class="language-plaintext highlighter-rouge">data_len()</code> to avoid any attempts 
at dead code elimination by the compiler:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">rng</span> <span class="o">=</span> <span class="nn">rand</span><span class="p">::</span><span class="nf">thread_rng</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span> <span class="n">DataType</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">1000000</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">rng</span><span class="nf">.gen_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="mi">0</span> <span class="k">=&gt;</span> <span class="n">data</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">BoolType</span><span class="p">)),</span>
        <span class="mi">1</span> <span class="k">=&gt;</span> <span class="n">data</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">IntType</span><span class="p">)),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="n">data</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">LongType</span><span class="p">)),</span>        
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1000</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">dt</span> <span class="n">in</span> <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">+=</span> <span class="nf">data_len</span><span class="p">(</span><span class="n">dt</span><span class="nf">.as_ref</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"Total len: {}"</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</code></pre></div></div>

<p>A <code class="language-plaintext highlighter-rouge">perf stat</code> on this program yields:</p>
<pre>
      6 777,73 msec task-clock                #    1,000 CPUs utilized          
            13      context-switches          #    0,002 K/sec                  
             1      cpu-migrations            #    0,000 K/sec                  
         4 047      page-faults               #    0,597 K/sec                  
23 800 190 663      cycles                    #    3,512 GHz                    
10 076 137 503      instructions              #    0,42  insn per cycle         
 4 012 788 756      branches                  #    592,055 M/sec                  
   667 673 937      branch-misses             #    16,64% of all branches        
     4 556 657      LLC-loads-misses     

   6,778608106 seconds time elapsed
</pre>

<p>One thing that immediately stands out is a high number of branch misses and low instructions-per-cycle.
Even though the code is short, an indirect jump to a random location can’t be predicted in many cases,
therefore the CPU pipeline stalls for a while and many cycles go to waste.</p>

<p>Another issue with runtime polymorphism is that it requires using heap for storing the objects.
We can’t store objects of different types directly in a vector, because their sizes might potentially 
differ. The size of each item in the vector must be the same. Therefore, we can only store 
references (pointers) in the vector and the objects data must be allocated elsewhere. 
Traversing these references causes random memory accesses (which is called often <em>pointer chasing</em>) 
which reduces the efficiency of CPU caches and may cause a lot of cache misses for large enough data structures. 
In this case <code class="language-plaintext highlighter-rouge">perf</code> recorded over 4 million of last-level-cache misses.</p>

<h2 id="performance-of-a-match--switch">Performance of a Match / Switch</h2>

<p>We can implement the same logic using enums and a match:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">enum</span> <span class="n">DataType</span> <span class="p">{</span>
    <span class="n">BoolType</span><span class="p">,</span>
    <span class="n">IntType</span><span class="p">,</span>
    <span class="n">LongType</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">data_len</span><span class="p">(</span><span class="n">data_type</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">DataType</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">data_type</span> <span class="p">{</span>
        <span class="nn">DataType</span><span class="p">::</span><span class="n">BoolType</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nn">DataType</span><span class="p">::</span><span class="n">IntType</span> <span class="k">=&gt;</span> <span class="mi">4</span><span class="p">,</span>
        <span class="nn">DataType</span><span class="p">::</span><span class="n">LongType</span> <span class="k">=&gt;</span> <span class="mi">8</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This allows to put the <code class="language-plaintext highlighter-rouge">DataType</code> objects inside of a vector directly, because now they are all the same size and have the same static type:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="o">&lt;</span><span class="n">DataType</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">rng</span> <span class="o">=</span> <span class="nn">rand</span><span class="p">::</span><span class="nf">thread_rng</span><span class="p">();</span>
<span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">1</span><span class="o">..</span><span class="mi">1000000</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">rng</span><span class="nf">.gen_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="mi">0</span> <span class="k">=&gt;</span> <span class="n">data</span><span class="nf">.push</span><span class="p">(</span><span class="nn">DataType</span><span class="p">::</span><span class="n">BoolType</span><span class="p">),</span>
        <span class="mi">1</span> <span class="k">=&gt;</span> <span class="n">data</span><span class="nf">.push</span><span class="p">(</span><span class="nn">DataType</span><span class="p">::</span><span class="n">IntType</span><span class="p">),</span>
        <span class="mi">2</span> <span class="k">=&gt;</span> <span class="n">data</span><span class="nf">.push</span><span class="p">(</span><span class="nn">DataType</span><span class="p">::</span><span class="n">LongType</span><span class="p">),</span>
        <span class="mi">_</span> <span class="k">=&gt;</span> <span class="p">{}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1000</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">dt</span> <span class="n">in</span> <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">+=</span> <span class="nf">data_len</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"Total len: {}"</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</code></pre></div></div>

<p>Let’s look at the code generated for <code class="language-plaintext highlighter-rouge">data_len</code>:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">movzbl</span> <span class="p">(</span><span class="o">%</span><span class="nb">rdi</span><span class="p">),</span><span class="o">%</span><span class="nb">eax</span>
<span class="nf">lea</span>    <span class="nv">anon.d7e157471cbbc210d945c8fcb95e1baa.3.llvm.2081724968588745877</span><span class="o">+</span><span class="mh">0xc</span><span class="p">,</span><span class="o">%</span><span class="nb">rcx</span>
<span class="nf">mov</span>    <span class="p">(</span><span class="o">%</span><span class="nb">rcx</span><span class="p">,</span><span class="o">%</span><span class="nb">rax</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span><span class="o">%</span><span class="nb">rax</span>
<span class="nf">retq</span>
</code></pre></div></div>

<p>There is no branching in this code! The compiler noticed a simple lookup table does 
the job. So not only the vector is now totally flat and there is no pointer chasing, 
but also there are no jumps. The effect on performance is significant:</p>

<pre>
      1 762,37 msec task-clock                #    1,000 CPUs utilized          
             8      context-switches          #    0,005 K/sec                  
             0      cpu-migrations            #    0,000 K/sec                  
           387      page-faults               #    0,220 K/sec                  
 6 361 343 641      cycles                    #    3,610 GHz                    
10 053 423 994      instructions              #    1,58  insn per cycle         
 3 009 768 006      branches                  #    1707,796 M/sec                  
     1 127 367      branch-misses             #    0,04% of all branches        
        33 221      LLC-loads-misses 

   1,762797864 seconds time elapsed
</pre>

<p>That’s almost 4 times faster! 
The numbers of branch misses and LLC misses are at least two orders of magnitude lower.</p>

<p>Of course, you may find more complex cases where branching would yield exactly same performance
as a virtual table dispatch, because often a switch / match is implemented by a jump-table as well.
However, generally, branching offers the compiler more flexibility to optimize because all the jump
targets are known in advance. In case of virtual dispatch, a static compiler may not know all the jump 
targets at the time of compilation so generally such code is harder to optimize.</p>

<h1 id="conclusions">Conclusions</h1>

<ul>
  <li>Polymorphism scales well when we want to extend the program by adding <em>types</em>, but it doesn’t scale
well when we want to add <em>functions</em> over these types.</li>
  <li>Branching scales well when we want to extend the program by adding <em>functions</em> but it doesn’t scale well when we want to add <em>types</em>.</li>
  <li>Branching is a cleaner solution when the dispatch target depends on more than a single type.</li>
  <li>Branching gives the compiler much more room to optimize.</li>
</ul>

<h1 id="further-reading">Further Reading</h1>
<p><a href="https://en.wikipedia.org/wiki/Expression_problem">Expression Problem</a></p>

  

<style>
#share-buttons { margin-top: 2em; }
#share-buttons > a {   
    display: inline-block;
    vertical-align: baseline;
}
#share-buttons > a > svg { 
    height: 1.2em; 
    width: 1.2em; 
    margin-left: .25em; 
    margin-right: .25em; 
    fill: gray; 
    position: relative; 
    top: .17em; 
}
#share-buttons > span { 
    margin-right: .4em 
}
#share-buttons > a:hover {cursor: pointer;}
#share-buttons > a.facebook:hover > svg {fill: #3B5998;}
#share-buttons > a.twitter:hover > svg {fill: #55ACEE;}
#share-buttons > a.linkedin:hover > svg {fill: #0077b5;}
#share-buttons > a.pinterest:hover > svg {fill: #CB2027;}
#share-buttons > a.mail:hover > svg {fill: #0077b5; }
</style>

<div id="share-buttons">
    <span style="color: gray;">Share on:</span>
    <a class="facebook" title="Share this on Facebook" href="http://www.facebook.com/share.php?u=/in-defense-of-switch/" target="_blank"> 
        <svg><use xlink:href="/assets/fontawesome/icons.svg#facebook"></use></svg>
    </a>
    <a class="twitter" title="Share this on Twitter" href="https://twitter.com/intent/tweet?text=/in-defense-of-switch/" target="_blank">
        <svg><use xlink:href="/assets/fontawesome/icons.svg#twitter"></use></svg>
    </a>
    <a class="linkedin" title="Share this on Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=/in-defense-of-switch/" target="_blank">
        <svg><use xlink:href="/assets/fontawesome/icons.svg#linkedin"></use></svg>
    </a>
    <a class="mail" title="Share this through Email" href="mailto:?&body=/in-defense-of-switch/">
        <svg><use xlink:href="/assets/fontawesome/icons.svg#envelope"></use></svg>
    </a>
</div>

  
    <hr>
    
        
      <div id="disqus_thread"></div>
      <script src="/assets/disqus/disqusloader.js"></script>
      <script>        
        disqusLoader('#disqus_thread', { scriptUrl: "//pkolaczk.disqus.com/embed.js" });
      </script> 
    
    <noscript>Please enable JavaScript to view comments.</noscript>
  
</article>


  <footer class="related">
    <div class="previous"><span>Previous Post</span><a href="/multiple-threadpools-rust/">Multiple Thread Pools in Rust</a></div>
    <div class="next"><span>Next Post</span><a href="/benchmarking-cassandra/">Benchmarking Apache Cassandra with Rust</a></div>
  </footer>


</body>
</html>
